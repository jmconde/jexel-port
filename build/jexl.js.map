{"version":3,"file":"jexl.js","sources":["../node_modules/jexl/lib/evaluator/handlers.js","../node_modules/jexl/lib/evaluator/Evaluator.js","../node_modules/jexl/lib/Lexer.js","../node_modules/jexl/lib/parser/handlers.js","../node_modules/jexl/lib/parser/states.js","../node_modules/jexl/lib/parser/Parser.js","../node_modules/jexl/lib/PromiseSync.js","../node_modules/jexl/lib/Expression.js","../node_modules/jexl/lib/grammar.js","../node_modules/jexl/lib/Jexl.js","../src/main.js"],"sourcesContent":["/*\n * Jexl\n * Copyright 2019 Tom Shawver\n */\n\n/**\n * Evaluates an ArrayLiteral by returning its value, with each element\n * independently run through the evaluator.\n * @param {{type: 'ObjectLiteral', value: <{}>}} ast An expression tree with an\n *      ObjectLiteral as the top node\n * @returns {Promise.<[]>} resolves to a map contained evaluated values.\n * @private\n */\nexports.ArrayLiteral = function(ast) {\n  return this.evalArray(ast.value)\n}\n\n/**\n * Evaluates a BinaryExpression node by running the Grammar's evaluator for\n * the given operator.\n * @param {{type: 'BinaryExpression', operator: <string>, left: {},\n *      right: {}}} ast An expression tree with a BinaryExpression as the top\n *      node\n * @returns {Promise<*>} resolves with the value of the BinaryExpression.\n * @private\n */\nexports.BinaryExpression = function(ast) {\n  return this.Promise.all([this.eval(ast.left), this.eval(ast.right)]).then(\n    arr => this._grammar[ast.operator].eval(arr[0], arr[1])\n  )\n}\n\n/**\n * Evaluates a ConditionalExpression node by first evaluating its test branch,\n * and resolving with the consequent branch if the test is truthy, or the\n * alternate branch if it is not. If there is no consequent branch, the test\n * result will be used instead.\n * @param {{type: 'ConditionalExpression', test: {}, consequent: {},\n *      alternate: {}}} ast An expression tree with a ConditionalExpression as\n *      the top node\n * @private\n */\nexports.ConditionalExpression = function(ast) {\n  return this.eval(ast.test).then(res => {\n    if (res) {\n      if (ast.consequent) {\n        return this.eval(ast.consequent)\n      }\n      return res\n    }\n    return this.eval(ast.alternate)\n  })\n}\n\n/**\n * Evaluates a FilterExpression by applying it to the subject value.\n * @param {{type: 'FilterExpression', relative: <boolean>, expr: {},\n *      subject: {}}} ast An expression tree with a FilterExpression as the top\n *      node\n * @returns {Promise<*>} resolves with the value of the FilterExpression.\n * @private\n */\nexports.FilterExpression = function(ast) {\n  return this.eval(ast.subject).then(subject => {\n    if (ast.relative) {\n      return this._filterRelative(subject, ast.expr)\n    }\n    return this._filterStatic(subject, ast.expr)\n  })\n}\n\n/**\n * Evaluates an Identifier by either stemming from the evaluated 'from'\n * expression tree or accessing the context provided when this Evaluator was\n * constructed.\n * @param {{type: 'Identifier', value: <string>, [from]: {}}} ast An expression\n *      tree with an Identifier as the top node\n * @returns {Promise<*>|*} either the identifier's value, or a Promise that\n *      will resolve with the identifier's value.\n * @private\n */\nexports.Identifier = function(ast) {\n  if (!ast.from) {\n    return ast.relative ? this._relContext[ast.value] : this._context[ast.value]\n  }\n  return this.eval(ast.from).then(context => {\n    if (context === undefined || context === null) {\n      return undefined\n    }\n    if (Array.isArray(context)) {\n      context = context[0]\n    }\n    return context[ast.value]\n  })\n}\n\n/**\n * Evaluates a Literal by returning its value property.\n * @param {{type: 'Literal', value: <string|number|boolean>}} ast An expression\n *      tree with a Literal as its only node\n * @returns {string|number|boolean} The value of the Literal node\n * @private\n */\nexports.Literal = function(ast) {\n  return ast.value\n}\n\n/**\n * Evaluates an ObjectLiteral by returning its value, with each key\n * independently run through the evaluator.\n * @param {{type: 'ObjectLiteral', value: <{}>}} ast An expression tree with an\n *      ObjectLiteral as the top node\n * @returns {Promise<{}>} resolves to a map contained evaluated values.\n * @private\n */\nexports.ObjectLiteral = function(ast) {\n  return this.evalMap(ast.value)\n}\n\n/**\n * Evaluates a Transform node by applying a function from the transforms map\n * to the subject value.\n * @param {{type: 'Transform', name: <string>, subject: {}}} ast An\n *      expression tree with a Transform as the top node\n * @returns {Promise<*>|*} the value of the transformation, or a Promise that\n *      will resolve with the transformed value.\n * @private\n */\nexports.Transform = function(ast) {\n  const transform = this._transforms[ast.name]\n  if (!transform) {\n    throw new Error(`Transform ${ast.name} is not defined.`)\n  }\n  return this.Promise.all([\n    this.eval(ast.subject),\n    this.evalArray(ast.args || [])\n  ]).then(arr => transform.apply(null, [arr[0]].concat(arr[1])))\n}\n\n/**\n * Evaluates a Unary expression by passing the right side through the\n * operator's eval function.\n * @param {{type: 'UnaryExpression', operator: <string>, right: {}}} ast An\n *      expression tree with a UnaryExpression as the top node\n * @returns {Promise<*>} resolves with the value of the UnaryExpression.\n * @constructor\n */\nexports.UnaryExpression = function(ast) {\n  return this.eval(ast.right).then(right =>\n    this._grammar[ast.operator].eval(right)\n  )\n}\n","/*\n * Jexl\n * Copyright 2019 Tom Shawver\n */\n\nconst handlers = require('./handlers')\n\n/**\n * The Evaluator takes a Jexl expression tree as generated by the\n * {@link Parser} and calculates its value within a given context. The\n * collection of transforms, context, and a relative context to be used as the\n * root for relative identifiers, are all specific to an Evaluator instance.\n * When any of these things change, a new instance is required.  However, a\n * single instance can be used to simultaneously evaluate many different\n * expressions, and does not have to be reinstantiated for each.\n * @param {{}} grammar A grammar map against which to evaluate the expression\n *      tree\n * @param {{}} [transforms] A map of transform names to transform functions. A\n *      transform function takes two arguments:\n *          - {*} val: A value to be transformed\n *          - {{}} args: A map of argument keys to their evaluated values, as\n *              specified in the expression string\n *      The transform function should return either the transformed value, or\n *      a Promises/A+ Promise object that resolves with the value and rejects\n *      or throws only when an unrecoverable error occurs. Transforms should\n *      generally return undefined when they don't make sense to be used on the\n *      given value type, rather than throw/reject. An error is only\n *      appropriate when the transform would normally return a value, but\n *      cannot due to some other failure.\n * @param {{}} [context] A map of variable keys to their values. This will be\n *      accessed to resolve the value of each non-relative identifier. Any\n *      Promise values will be passed to the expression as their resolved\n *      value.\n * @param {{}|Array<{}|Array>} [relativeContext] A map or array to be accessed\n *      to resolve the value of a relative identifier.\n * @param {function} promise A constructor for the Promise class to be used;\n *      probably either Promise or PromiseSync.\n */\nclass Evaluator {\n  constructor(\n    grammar,\n    transforms,\n    context,\n    relativeContext,\n    promise = Promise\n  ) {\n    this._grammar = grammar\n    this._transforms = transforms || {}\n    this._context = context || {}\n    this._relContext = relativeContext || this._context\n    this.Promise = promise\n  }\n\n  /**\n   * Evaluates an expression tree within the configured context.\n   * @param {{}} ast An expression tree object\n   * @returns {Promise<*>} resolves with the resulting value of the expression.\n   */\n  eval(ast) {\n    return this.Promise.resolve().then(() => {\n      return handlers[ast.type].call(this, ast)\n    })\n  }\n\n  /**\n   * Simultaneously evaluates each expression within an array, and delivers the\n   * response as an array with the resulting values at the same indexes as their\n   * originating expressions.\n   * @param {Array<string>} arr An array of expression strings to be evaluated\n   * @returns {Promise<Array<{}>>} resolves with the result array\n   */\n  evalArray(arr) {\n    return this.Promise.all(arr.map(elem => this.eval(elem)))\n  }\n\n  /**\n   * Simultaneously evaluates each expression within a map, and delivers the\n   * response as a map with the same keys, but with the evaluated result for each\n   * as their value.\n   * @param {{}} map A map of expression names to expression trees to be\n   *      evaluated\n   * @returns {Promise<{}>} resolves with the result map.\n   */\n  evalMap(map) {\n    const keys = Object.keys(map)\n    const result = {}\n    const asts = keys.map(key => {\n      return this.eval(map[key])\n    })\n    return this.Promise.all(asts).then(vals => {\n      vals.forEach((val, idx) => {\n        result[keys[idx]] = val\n      })\n      return result\n    })\n  }\n\n  /**\n   * Applies a filter expression with relative identifier elements to a subject.\n   * The intent is for the subject to be an array of subjects that will be\n   * individually used as the relative context against the provided expression\n   * tree. Only the elements whose expressions result in a truthy value will be\n   * included in the resulting array.\n   *\n   * If the subject is not an array of values, it will be converted to a single-\n   * element array before running the filter.\n   * @param {*} subject The value to be filtered usually an array. If this value is\n   *      not an array, it will be converted to an array with this value as the\n   *      only element.\n   * @param {{}} expr The expression tree to run against each subject. If the\n   *      tree evaluates to a truthy result, then the value will be included in\n   *      the returned array otherwise, it will be eliminated.\n   * @returns {Promise<Array>} resolves with an array of values that passed the\n   *      expression filter.\n   * @private\n   */\n  _filterRelative(subject, expr) {\n    const promises = []\n    if (!Array.isArray(subject)) {\n      subject = subject === undefined ? [] : [subject]\n    }\n    subject.forEach(elem => {\n      const evalInst = new Evaluator(\n        this._grammar,\n        this._transforms,\n        this._context,\n        elem,\n        this.Promise\n      )\n      promises.push(evalInst.eval(expr))\n    })\n    return this.Promise.all(promises).then(values => {\n      const results = []\n      values.forEach((value, idx) => {\n        if (value) {\n          results.push(subject[idx])\n        }\n      })\n      return results\n    })\n  }\n\n  /**\n   * Applies a static filter expression to a subject value.  If the filter\n   * expression evaluates to boolean true, the subject is returned if false,\n   * undefined.\n   *\n   * For any other resulting value of the expression, this function will attempt\n   * to respond with the property at that name or index of the subject.\n   * @param {*} subject The value to be filtered.  Usually an Array (for which\n   *      the expression would generally resolve to a numeric index) or an\n   *      Object (for which the expression would generally resolve to a string\n   *      indicating a property name)\n   * @param {{}} expr The expression tree to run against the subject\n   * @returns {Promise<*>} resolves with the value of the drill-down.\n   * @private\n   */\n  _filterStatic(subject, expr) {\n    return this.eval(expr).then(res => {\n      if (typeof res === 'boolean') {\n        return res ? subject : undefined\n      }\n      return subject[res]\n    })\n  }\n}\n\nmodule.exports = Evaluator\n","/*\n * Jexl\n * Copyright 2019 Tom Shawver\n */\n\nconst numericRegex = /^-?(?:(?:[0-9]*\\.[0-9]+)|[0-9]+)$/\nconst identRegex = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/\nconst escEscRegex = /\\\\\\\\/\nconst whitespaceRegex = /^\\s*$/\nconst preOpRegexElems = [\n  // Strings\n  \"'(?:(?:\\\\\\\\')|[^'])*'\",\n  '\"(?:(?:\\\\\\\\\")|[^\"])*\"',\n  // Whitespace\n  '\\\\s+',\n  // Booleans\n  '\\\\btrue\\\\b',\n  '\\\\bfalse\\\\b'\n]\nconst postOpRegexElems = [\n  // Identifiers\n  '[a-zA-Z_\\\\$][a-zA-Z0-9_\\\\$]*',\n  // Numerics (without negative symbol)\n  '(?:(?:[0-9]*\\\\.[0-9]+)|[0-9]+)'\n]\nconst minusNegatesAfter = [\n  'binaryOp',\n  'unaryOp',\n  'openParen',\n  'openBracket',\n  'question',\n  'colon'\n]\n\n/**\n * Lexer is a collection of stateless, statically-accessed functions for the\n * lexical parsing of a Jexl string.  Its responsibility is to identify the\n * \"parts of speech\" of a Jexl expression, and tokenize and label each, but\n * to do only the most minimal syntax checking; the only errors the Lexer\n * should be concerned with are if it's unable to identify the utility of\n * any of its tokens.  Errors stemming from these tokens not being in a\n * sensible configuration should be left for the Parser to handle.\n * @type {{}}\n */\nclass Lexer {\n  constructor(grammar) {\n    this._grammar = grammar\n  }\n\n  /**\n   * Splits a Jexl expression string into an array of expression elements.\n   * @param {string} str A Jexl expression string\n   * @returns {Array<string>} An array of substrings defining the functional\n   *      elements of the expression.\n   */\n  getElements(str) {\n    const regex = this._getSplitRegex()\n    return str.split(regex).filter(elem => {\n      // Remove empty strings\n      return elem\n    })\n  }\n\n  /**\n   * Converts an array of expression elements into an array of tokens.  Note that\n   * the resulting array may not equal the element array in length, as any\n   * elements that consist only of whitespace get appended to the previous\n   * token's \"raw\" property.  For the structure of a token object, please see\n   * {@link Lexer#tokenize}.\n   * @param {Array<string>} elements An array of Jexl expression elements to be\n   *      converted to tokens\n   * @returns {Array<{type, value, raw}>} an array of token objects.\n   */\n  getTokens(elements) {\n    const tokens = []\n    let negate = false\n    for (let i = 0; i < elements.length; i++) {\n      if (this._isWhitespace(elements[i])) {\n        if (tokens.length) {\n          tokens[tokens.length - 1].raw += elements[i]\n        }\n      } else if (elements[i] === '-' && this._isNegative(tokens)) {\n        negate = true\n      } else {\n        if (negate) {\n          elements[i] = '-' + elements[i]\n          negate = false\n        }\n        tokens.push(this._createToken(elements[i]))\n      }\n    }\n    // Catch a - at the end of the string. Let the parser handle that issue.\n    if (negate) {\n      tokens.push(this._createToken('-'))\n    }\n    return tokens\n  }\n\n  /**\n   * Converts a Jexl string into an array of tokens.  Each token is an object\n   * in the following format:\n   *\n   *     {\n   *         type: <string>,\n   *         [name]: <string>,\n   *         value: <boolean|number|string>,\n   *         raw: <string>\n   *     }\n   *\n   * Type is one of the following:\n   *\n   *      literal, identifier, binaryOp, unaryOp\n   *\n   * OR, if the token is a control character its type is the name of the element\n   * defined in the Grammar.\n   *\n   * Name appears only if the token is a control string found in\n   * {@link grammar#elements}, and is set to the name of the element.\n   *\n   * Value is the value of the token in the correct type (boolean or numeric as\n   * appropriate). Raw is the string representation of this value taken directly\n   * from the expression string, including any trailing spaces.\n   * @param {string} str The Jexl string to be tokenized\n   * @returns {Array<{type, value, raw}>} an array of token objects.\n   * @throws {Error} if the provided string contains an invalid token.\n   */\n  tokenize(str) {\n    const elements = this.getElements(str)\n    return this.getTokens(elements)\n  }\n\n  /**\n   * Creates a new token object from an element of a Jexl string. See\n   * {@link Lexer#tokenize} for a description of the token object.\n   * @param {string} element The element from which a token should be made\n   * @returns {{value: number|boolean|string, [name]: string, type: string,\n   *      raw: string}} a token object describing the provided element.\n   * @throws {Error} if the provided string is not a valid expression element.\n   * @private\n   */\n  _createToken(element) {\n    const token = {\n      type: 'literal',\n      value: element,\n      raw: element\n    }\n    if (element[0] === '\"' || element[0] === \"'\") {\n      token.value = this._unquote(element)\n    } else if (element.match(numericRegex)) {\n      token.value = parseFloat(element)\n    } else if (element === 'true' || element === 'false') {\n      token.value = element === 'true'\n    } else if (this._grammar[element]) {\n      token.type = this._grammar[element].type\n    } else if (element.match(identRegex)) {\n      token.type = 'identifier'\n    } else {\n      throw new Error(`Invalid expression token: ${element}`)\n    }\n    return token\n  }\n\n  /**\n   * Escapes a string so that it can be treated as a string literal within a\n   * regular expression.\n   * @param {string} str The string to be escaped\n   * @returns {string} the RegExp-escaped string.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Regular_Expressions\n   * @private\n   */\n  _escapeRegExp(str) {\n    str = str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n    if (str.match(identRegex)) {\n      str = '\\\\b' + str + '\\\\b'\n    }\n    return str\n  }\n\n  /**\n   * Gets a RegEx object appropriate for splitting a Jexl string into its core\n   * elements.\n   * @returns {RegExp} An element-splitting RegExp object\n   * @private\n   */\n  _getSplitRegex() {\n    if (!this._splitRegex) {\n      // Sort by most characters to least, then regex escape each\n      const elemArray = Object.keys(this._grammar)\n        .sort((a, b) => {\n          return b.length - a.length\n        })\n        .map(elem => {\n          return this._escapeRegExp(elem)\n        }, this)\n      this._splitRegex = new RegExp(\n        '(' +\n          [\n            preOpRegexElems.join('|'),\n            elemArray.join('|'),\n            postOpRegexElems.join('|')\n          ].join('|') +\n          ')'\n      )\n    }\n    return this._splitRegex\n  }\n\n  /**\n   * Determines whether the addition of a '-' token should be interpreted as a\n   * negative symbol for an upcoming number, given an array of tokens already\n   * processed.\n   * @param {Array<Object>} tokens An array of tokens already processed\n   * @returns {boolean} true if adding a '-' should be considered a negative\n   *      symbol; false otherwise\n   * @private\n   */\n  _isNegative(tokens) {\n    if (!tokens.length) return true\n    return minusNegatesAfter.some(\n      type => type === tokens[tokens.length - 1].type\n    )\n  }\n\n  /**\n   * A utility function to determine if a string consists of only space\n   * characters.\n   * @param {string} str A string to be tested\n   * @returns {boolean} true if the string is empty or consists of only spaces;\n   *      false otherwise.\n   * @private\n   */\n  _isWhitespace(str) {\n    return !!str.match(whitespaceRegex)\n  }\n\n  /**\n   * Removes the beginning and trailing quotes from a string, unescapes any\n   * escaped quotes on its interior, and unescapes any escaped escape\n   * characters. Note that this function is not defensive; it assumes that the\n   * provided string is not empty, and that its first and last characters are\n   * actually quotes.\n   * @param {string} str A string whose first and last characters are quotes\n   * @returns {string} a string with the surrounding quotes stripped and escapes\n   *      properly processed.\n   * @private\n   */\n  _unquote(str) {\n    const quote = str[0]\n    const escQuoteRegex = new RegExp('\\\\\\\\' + quote, 'g')\n    return str\n      .substr(1, str.length - 2)\n      .replace(escQuoteRegex, quote)\n      .replace(escEscRegex, '\\\\')\n  }\n}\n\nmodule.exports = Lexer\n","/*\n * Jexl\n * Copyright 2019 Tom Shawver\n */\n\n/**\n * Handles a subexpression that's used to define a transform argument's value.\n * @param {{type: <string>}} ast The subexpression tree\n */\nexports.argVal = function(ast) {\n  this._cursor.args.push(ast)\n}\n\n/**\n * Handles new array literals by adding them as a new node in the AST,\n * initialized with an empty array.\n */\nexports.arrayStart = function() {\n  this._placeAtCursor({\n    type: 'ArrayLiteral',\n    value: []\n  })\n}\n\n/**\n * Handles a subexpression representing an element of an array literal.\n * @param {{type: <string>}} ast The subexpression tree\n */\nexports.arrayVal = function(ast) {\n  if (ast) {\n    this._cursor.value.push(ast)\n  }\n}\n\n/**\n * Handles tokens of type 'binaryOp', indicating an operation that has two\n * inputs: a left side and a right side.\n * @param {{type: <string>}} token A token object\n */\nexports.binaryOp = function(token) {\n  const precedence = this._grammar[token.value].precedence || 0\n  let parent = this._cursor._parent\n  while (\n    parent &&\n    parent.operator &&\n    this._grammar[parent.operator].precedence >= precedence\n  ) {\n    this._cursor = parent\n    parent = parent._parent\n  }\n  const node = {\n    type: 'BinaryExpression',\n    operator: token.value,\n    left: this._cursor\n  }\n  this._setParent(this._cursor, node)\n  this._cursor = parent\n  this._placeAtCursor(node)\n}\n\n/**\n * Handles successive nodes in an identifier chain.  More specifically, it\n * sets values that determine how the following identifier gets placed in the\n * AST.\n */\nexports.dot = function() {\n  this._nextIdentEncapsulate =\n    this._cursor &&\n    this._cursor.type !== 'UnaryExpression' &&\n    (this._cursor.type !== 'BinaryExpression' ||\n      (this._cursor.type === 'BinaryExpression' && this._cursor.right))\n  this._nextIdentRelative =\n    !this._cursor || (this._cursor && !this._nextIdentEncapsulate)\n  if (this._nextIdentRelative) {\n    this._relative = true\n  }\n}\n\n/**\n * Handles a subexpression used for filtering an array returned by an\n * identifier chain.\n * @param {{type: <string>}} ast The subexpression tree\n */\nexports.filter = function(ast) {\n  this._placeBeforeCursor({\n    type: 'FilterExpression',\n    expr: ast,\n    relative: this._subParser.isRelative(),\n    subject: this._cursor\n  })\n}\n\n/**\n * Handles identifier tokens by adding them as a new node in the AST.\n * @param {{type: <string>}} token A token object\n */\nexports.identifier = function(token) {\n  const node = {\n    type: 'Identifier',\n    value: token.value\n  }\n  if (this._nextIdentEncapsulate) {\n    node.from = this._cursor\n    this._placeBeforeCursor(node)\n    this._nextIdentEncapsulate = false\n  } else {\n    if (this._nextIdentRelative) {\n      node.relative = true\n      this._nextIdentRelative = false\n    }\n    this._placeAtCursor(node)\n  }\n}\n\n/**\n * Handles literal values, such as strings, booleans, and numerics, by adding\n * them as a new node in the AST.\n * @param {{type: <string>}} token A token object\n */\nexports.literal = function(token) {\n  this._placeAtCursor({\n    type: 'Literal',\n    value: token.value\n  })\n}\n\n/**\n * Queues a new object literal key to be written once a value is collected.\n * @param {{type: <string>}} token A token object\n */\nexports.objKey = function(token) {\n  this._curObjKey = token.value\n}\n\n/**\n * Handles new object literals by adding them as a new node in the AST,\n * initialized with an empty object.\n */\nexports.objStart = function() {\n  this._placeAtCursor({\n    type: 'ObjectLiteral',\n    value: {}\n  })\n}\n\n/**\n * Handles an object value by adding its AST to the queued key on the object\n * literal node currently at the cursor.\n * @param {{type: <string>}} ast The subexpression tree\n */\nexports.objVal = function(ast) {\n  this._cursor.value[this._curObjKey] = ast\n}\n\n/**\n * Handles traditional subexpressions, delineated with the groupStart and\n * groupEnd elements.\n * @param {{type: <string>}} ast The subexpression tree\n */\nexports.subExpression = function(ast) {\n  this._placeAtCursor(ast)\n}\n\n/**\n * Handles a completed alternate subexpression of a ternary operator.\n * @param {{type: <string>}} ast The subexpression tree\n */\nexports.ternaryEnd = function(ast) {\n  this._cursor.alternate = ast\n}\n\n/**\n * Handles a completed consequent subexpression of a ternary operator.\n * @param {{type: <string>}} ast The subexpression tree\n */\nexports.ternaryMid = function(ast) {\n  this._cursor.consequent = ast\n}\n\n/**\n * Handles the start of a new ternary expression by encapsulating the entire\n * AST in a ConditionalExpression node, and using the existing tree as the\n * test element.\n */\nexports.ternaryStart = function() {\n  this._tree = {\n    type: 'ConditionalExpression',\n    test: this._tree\n  }\n  this._cursor = this._tree\n}\n\n/**\n * Handles identifier tokens when used to indicate the name of a transform to\n * be applied.\n * @param {{type: <string>}} token A token object\n */\nexports.transform = function(token) {\n  this._placeBeforeCursor({\n    type: 'Transform',\n    name: token.value,\n    args: [],\n    subject: this._cursor\n  })\n}\n\n/**\n * Handles token of type 'unaryOp', indicating that the operation has only\n * one input: a right side.\n * @param {{type: <string>}} token A token object\n */\nexports.unaryOp = function(token) {\n  this._placeAtCursor({\n    type: 'UnaryExpression',\n    operator: token.value\n  })\n}\n","/*\n * Jexl\n * Copyright 2019 Tom Shawver\n */\n\nconst h = require('./handlers')\n\n/**\n * A mapping of all states in the finite state machine to a set of instructions\n * for handling or transitioning into other states. Each state can be handled\n * in one of two schemes: a tokenType map, or a subHandler.\n *\n * Standard expression elements are handled through the tokenType object. This\n * is an object map of all legal token types to encounter in this state (and\n * any unexpected token types will generate a thrown error) to an options\n * object that defines how they're handled.  The available options are:\n *\n *      {string} toState: The name of the state to which to transition\n *          immediately after handling this token\n *      {string} handler: The handler function to call when this token type is\n *          encountered in this state.  If omitted, the default handler\n *          matching the token's \"type\" property will be called. If the handler\n *          function does not exist, no call will be made and no error will be\n *          generated.  This is useful for tokens whose sole purpose is to\n *          transition to other states.\n *\n * States that consume a subexpression should define a subHandler, the\n * function to be called with an expression tree argument when the\n * subexpression is complete. Completeness is determined through the\n * endStates object, which maps tokens on which an expression should end to the\n * state to which to transition once the subHandler function has been called.\n *\n * Additionally, any state in which it is legal to mark the AST as completed\n * should have a 'completable' property set to boolean true.  Attempting to\n * call {@link Parser#complete} in any state without this property will result\n * in a thrown Error.\n *\n * @type {{}}\n */\nexports.states = {\n  expectOperand: {\n    tokenTypes: {\n      literal: { toState: 'expectBinOp' },\n      identifier: { toState: 'identifier' },\n      unaryOp: {},\n      openParen: { toState: 'subExpression' },\n      openCurl: { toState: 'expectObjKey', handler: h.objStart },\n      dot: { toState: 'traverse' },\n      openBracket: { toState: 'arrayVal', handler: h.arrayStart }\n    }\n  },\n  expectBinOp: {\n    tokenTypes: {\n      binaryOp: { toState: 'expectOperand' },\n      pipe: { toState: 'expectTransform' },\n      dot: { toState: 'traverse' },\n      question: { toState: 'ternaryMid', handler: h.ternaryStart }\n    },\n    completable: true\n  },\n  expectTransform: {\n    tokenTypes: {\n      identifier: { toState: 'postTransform', handler: h.transform }\n    }\n  },\n  expectObjKey: {\n    tokenTypes: {\n      identifier: { toState: 'expectKeyValSep', handler: h.objKey },\n      closeCurl: { toState: 'expectBinOp' }\n    }\n  },\n  expectKeyValSep: {\n    tokenTypes: {\n      colon: { toState: 'objVal' }\n    }\n  },\n  postTransform: {\n    tokenTypes: {\n      openParen: { toState: 'argVal' },\n      binaryOp: { toState: 'expectOperand' },\n      dot: { toState: 'traverse' },\n      openBracket: { toState: 'filter' },\n      pipe: { toState: 'expectTransform' }\n    },\n    completable: true\n  },\n  postTransformArgs: {\n    tokenTypes: {\n      binaryOp: { toState: 'expectOperand' },\n      dot: { toState: 'traverse' },\n      openBracket: { toState: 'filter' },\n      pipe: { toState: 'expectTransform' }\n    },\n    completable: true\n  },\n  identifier: {\n    tokenTypes: {\n      binaryOp: { toState: 'expectOperand' },\n      dot: { toState: 'traverse' },\n      openBracket: { toState: 'filter' },\n      pipe: { toState: 'expectTransform' },\n      question: { toState: 'ternaryMid', handler: h.ternaryStart }\n    },\n    completable: true\n  },\n  traverse: {\n    tokenTypes: {\n      identifier: { toState: 'identifier' }\n    }\n  },\n  filter: {\n    subHandler: h.filter,\n    endStates: {\n      closeBracket: 'identifier'\n    }\n  },\n  subExpression: {\n    subHandler: h.subExpression,\n    endStates: {\n      closeParen: 'expectBinOp'\n    }\n  },\n  argVal: {\n    subHandler: h.argVal,\n    endStates: {\n      comma: 'argVal',\n      closeParen: 'postTransformArgs'\n    }\n  },\n  objVal: {\n    subHandler: h.objVal,\n    endStates: {\n      comma: 'expectObjKey',\n      closeCurl: 'expectBinOp'\n    }\n  },\n  arrayVal: {\n    subHandler: h.arrayVal,\n    endStates: {\n      comma: 'arrayVal',\n      closeBracket: 'expectBinOp'\n    }\n  },\n  ternaryMid: {\n    subHandler: h.ternaryMid,\n    endStates: {\n      colon: 'ternaryEnd'\n    }\n  },\n  ternaryEnd: {\n    subHandler: h.ternaryEnd,\n    completable: true\n  }\n}\n","/*\n * Jexl\n * Copyright 2019 Tom Shawver\n */\n\nconst handlers = require('./handlers')\nconst states = require('./states').states\n\n/**\n * The Parser is a state machine that converts tokens from the {@link Lexer}\n * into an Abstract Syntax Tree (AST), capable of being evaluated in any\n * context by the {@link Evaluator}.  The Parser expects that all tokens\n * provided to it are legal and typed properly according to the grammar, but\n * accepts that the tokens may still be in an invalid order or in some other\n * unparsable configuration that requires it to throw an Error.\n * @param {{}} grammar The grammar map to use to parse Jexl strings\n * @param {string} [prefix] A string prefix to prepend to the expression string\n *      for error messaging purposes.  This is useful for when a new Parser is\n *      instantiated to parse an subexpression, as the parent Parser's\n *      expression string thus far can be passed for a more user-friendly\n *      error message.\n * @param {{}} [stopMap] A mapping of token types to any truthy value. When the\n *      token type is encountered, the parser will return the mapped value\n *      instead of boolean false.\n */\nclass Parser {\n  constructor(grammar, prefix, stopMap) {\n    this._grammar = grammar\n    this._state = 'expectOperand'\n    this._tree = null\n    this._exprStr = prefix || ''\n    this._relative = false\n    this._stopMap = stopMap || {}\n  }\n\n  /**\n   * Processes a new token into the AST and manages the transitions of the state\n   * machine.\n   * @param {{type: <string>}} token A token object, as provided by the\n   *      {@link Lexer#tokenize} function.\n   * @throws {Error} if a token is added when the Parser has been marked as\n   *      complete by {@link #complete}, or if an unexpected token type is added.\n   * @returns {boolean|*} the stopState value if this parser encountered a token\n   *      in the stopState mapb false if tokens can continue.\n   */\n  addToken(token) {\n    if (this._state === 'complete') {\n      throw new Error('Cannot add a new token to a completed Parser')\n    }\n    const state = states[this._state]\n    const startExpr = this._exprStr\n    this._exprStr += token.raw\n    if (state.subHandler) {\n      if (!this._subParser) {\n        this._startSubExpression(startExpr)\n      }\n      const stopState = this._subParser.addToken(token)\n      if (stopState) {\n        this._endSubExpression()\n        if (this._parentStop) return stopState\n        this._state = stopState\n      }\n    } else if (state.tokenTypes[token.type]) {\n      const typeOpts = state.tokenTypes[token.type]\n      let handleFunc = handlers[token.type]\n      if (typeOpts.handler) {\n        handleFunc = typeOpts.handler\n      }\n      if (handleFunc) {\n        handleFunc.call(this, token)\n      }\n      if (typeOpts.toState) {\n        this._state = typeOpts.toState\n      }\n    } else if (this._stopMap[token.type]) {\n      return this._stopMap[token.type]\n    } else {\n      throw new Error(\n        `Token ${token.raw} (${token.type}) unexpected in expression: ${this._exprStr}`\n      )\n    }\n    return false\n  }\n\n  /**\n   * Processes an array of tokens iteratively through the {@link #addToken}\n   * function.\n   * @param {Array<{type: <string>}>} tokens An array of tokens, as provided by\n   *      the {@link Lexer#tokenize} function.\n   */\n  addTokens(tokens) {\n    tokens.forEach(this.addToken, this)\n  }\n\n  /**\n   * Marks this Parser instance as completed and retrieves the full AST.\n   * @returns {{}|null} a full expression tree, ready for evaluation by the\n   *      {@link Evaluator#eval} function, or null if no tokens were passed to\n   *      the parser before complete was called\n   * @throws {Error} if the parser is not in a state where it's legal to end\n   *      the expression, indicating that the expression is incomplete\n   */\n  complete() {\n    if (this._cursor && !states[this._state].completable) {\n      throw new Error(`Unexpected end of expression: ${this._exprStr}`)\n    }\n    if (this._subParser) {\n      this._endSubExpression()\n    }\n    this._state = 'complete'\n    return this._cursor ? this._tree : null\n  }\n\n  /**\n   * Indicates whether the expression tree contains a relative path identifier.\n   * @returns {boolean} true if a relative identifier exists false otherwise.\n   */\n  isRelative() {\n    return this._relative\n  }\n\n  /**\n   * Ends a subexpression by completing the subParser and passing its result\n   * to the subHandler configured in the current state.\n   * @private\n   */\n  _endSubExpression() {\n    states[this._state].subHandler.call(this, this._subParser.complete())\n    this._subParser = null\n  }\n\n  /**\n   * Places a new tree node at the current position of the cursor (to the 'right'\n   * property) and then advances the cursor to the new node. This function also\n   * handles setting the parent of the new node.\n   * @param {{type: <string>}} node A node to be added to the AST\n   * @private\n   */\n  _placeAtCursor(node) {\n    if (!this._cursor) {\n      this._tree = node\n    } else {\n      this._cursor.right = node\n      this._setParent(node, this._cursor)\n    }\n    this._cursor = node\n  }\n\n  /**\n   * Places a tree node before the current position of the cursor, replacing\n   * the node that the cursor currently points to. This should only be called in\n   * cases where the cursor is known to exist, and the provided node already\n   * contains a pointer to what's at the cursor currently.\n   * @param {{type: <string>}} node A node to be added to the AST\n   * @private\n   */\n  _placeBeforeCursor(node) {\n    this._cursor = this._cursor._parent\n    this._placeAtCursor(node)\n  }\n\n  /**\n   * Sets the parent of a node by creating a non-enumerable _parent property\n   * that points to the supplied parent argument.\n   * @param {{type: <string>}} node A node of the AST on which to set a new\n   *      parent\n   * @param {{type: <string>}} parent An existing node of the AST to serve as the\n   *      parent of the new node\n   * @private\n   */\n  _setParent(node, parent) {\n    Object.defineProperty(node, '_parent', {\n      value: parent,\n      writable: true\n    })\n  }\n\n  /**\n   * Prepares the Parser to accept a subexpression by (re)instantiating the\n   * subParser.\n   * @param {string} [exprStr] The expression string to prefix to the new Parser\n   * @private\n   */\n  _startSubExpression(exprStr) {\n    let endStates = states[this._state].endStates\n    if (!endStates) {\n      this._parentStop = true\n      endStates = this._stopMap\n    }\n    this._subParser = new Parser(this._grammar, exprStr, endStates)\n  }\n}\n\nmodule.exports = Parser\n","/*\n * Jexl\n * Copyright 2019 Tom Shawver\n */\n\nclass PromiseSync {\n  constructor(fn) {\n    fn(this._resolve.bind(this), this._reject.bind(this))\n  }\n\n  catch(rejected) {\n    if (this.error) {\n      try {\n        this._resolve(rejected(this.error))\n      } catch (e) {\n        this._reject(e)\n      }\n    }\n    return this\n  }\n\n  then(resolved, rejected) {\n    if (!this.error) {\n      try {\n        this._resolve(resolved(this.value))\n      } catch (e) {\n        this._reject(e)\n      }\n    }\n    if (rejected) this.catch(rejected)\n    return this\n  }\n\n  _reject(error) {\n    this.value = undefined\n    this.error = error\n  }\n\n  _resolve(val) {\n    if (val instanceof PromiseSync) {\n      if (val.error) {\n        this._reject(val.error)\n      } else {\n        this._resolve(val.value)\n      }\n    } else {\n      this.value = val\n      this.error = undefined\n    }\n  }\n}\n\nPromiseSync.all = vals =>\n  new PromiseSync(resolve => {\n    const resolved = vals.map(val => {\n      while (val instanceof PromiseSync) {\n        if (val.error) throw Error(val.error)\n        val = val.value\n      }\n      return val\n    })\n    resolve(resolved)\n  })\n\nPromiseSync.resolve = val => new PromiseSync(resolve => resolve(val))\n\nPromiseSync.reject = error =>\n  new PromiseSync((resolve, reject) => reject(error))\n\nmodule.exports = PromiseSync\n","/*\n * Jexl\n * Copyright 2019 Tom Shawver\n */\n\nconst Evaluator = require('./evaluator/Evaluator')\nconst Lexer = require('./Lexer')\nconst Parser = require('./parser/Parser')\nconst PromiseSync = require('./PromiseSync')\n\nclass Expression {\n  constructor(lang, exprStr) {\n    this._lang = lang\n    this._lexer = new Lexer(lang.grammar)\n    this._exprStr = exprStr\n    this._ast = null\n  }\n\n  /**\n   * Forces a compilation of the expression string that this Expression object\n   * was constructed with. This function can be called multiple times; useful\n   * if the language elements of the associated Jexl instance change.\n   * @returns {Expression} this Expression instance, for convenience\n   */\n  compile() {\n    const lexer = new Lexer(this._lang.grammar)\n    const parser = new Parser(this._lang.grammar)\n    const tokens = lexer.tokenize(this._exprStr)\n    parser.addTokens(tokens)\n    this._ast = parser.complete()\n    return this\n  }\n\n  /**\n   * Asynchronously evaluates the expression within an optional context.\n   * @param {Object} [context] A mapping of variables to values, which will be\n   *      made accessible to the Jexl expression when evaluating it\n   * @returns {Promise<*>} resolves with the result of the evaluation.\n   */\n  eval(context = {}) {\n    return this._eval(context, Promise)\n  }\n\n  /**\n   * Synchronously evaluates the expression within an optional context.\n   * @param {Object} [context] A mapping of variables to values, which will be\n   *      made accessible to the Jexl expression when evaluating it\n   * @returns {*} the result of the evaluation.\n   * @throws {*} on error\n   */\n  evalSync(context = {}) {\n    const res = this._eval(context, PromiseSync)\n    if (res.error) throw res.error\n    return res.value\n  }\n\n  _eval(context, promise) {\n    return promise.resolve().then(() => {\n      const ast = this._getAst()\n      const evaluator = new Evaluator(\n        this._lang.grammar,\n        this._lang.transforms,\n        context,\n        undefined,\n        promise\n      )\n      return evaluator.eval(ast)\n    })\n  }\n\n  _getAst() {\n    if (!this._ast) this.compile()\n    return this._ast\n  }\n}\n\nmodule.exports = Expression\n","/*\n * Jexl\n * Copyright 2019 Tom Shawver\n */\n\n/* eslint eqeqeq:0 */\n\n/**\n * A map of all expression elements to their properties. Note that changes\n * here may require changes in the Lexer or Parser.\n * @type {{}}\n */\nexports.elements = {\n  '.': { type: 'dot' },\n  '[': { type: 'openBracket' },\n  ']': { type: 'closeBracket' },\n  '|': { type: 'pipe' },\n  '{': { type: 'openCurl' },\n  '}': { type: 'closeCurl' },\n  ':': { type: 'colon' },\n  ',': { type: 'comma' },\n  '(': { type: 'openParen' },\n  ')': { type: 'closeParen' },\n  '?': { type: 'question' },\n  '+': {\n    type: 'binaryOp',\n    precedence: 30,\n    eval: (left, right) => left + right\n  },\n  '-': {\n    type: 'binaryOp',\n    precedence: 30,\n    eval: (left, right) => left - right\n  },\n  '*': {\n    type: 'binaryOp',\n    precedence: 40,\n    eval: (left, right) => left * right\n  },\n  '/': {\n    type: 'binaryOp',\n    precedence: 40,\n    eval: (left, right) => left / right\n  },\n  '//': {\n    type: 'binaryOp',\n    precedence: 40,\n    eval: (left, right) => Math.floor(left / right)\n  },\n  '%': {\n    type: 'binaryOp',\n    precedence: 50,\n    eval: (left, right) => left % right\n  },\n  '^': {\n    type: 'binaryOp',\n    precedence: 50,\n    eval: (left, right) => Math.pow(left, right)\n  },\n  '==': {\n    type: 'binaryOp',\n    precedence: 20,\n    eval: (left, right) => left == right\n  },\n  '!=': {\n    type: 'binaryOp',\n    precedence: 20,\n    eval: (left, right) => left != right\n  },\n  '>': {\n    type: 'binaryOp',\n    precedence: 20,\n    eval: (left, right) => left > right\n  },\n  '>=': {\n    type: 'binaryOp',\n    precedence: 20,\n    eval: (left, right) => left >= right\n  },\n  '<': {\n    type: 'binaryOp',\n    precedence: 20,\n    eval: (left, right) => left < right\n  },\n  '<=': {\n    type: 'binaryOp',\n    precedence: 20,\n    eval: (left, right) => left <= right\n  },\n  '&&': {\n    type: 'binaryOp',\n    precedence: 10,\n    eval: (left, right) => left && right\n  },\n  '||': {\n    type: 'binaryOp',\n    precedence: 10,\n    eval: (left, right) => left || right\n  },\n  in: {\n    type: 'binaryOp',\n    precedence: 20,\n    eval: (left, right) => {\n      if (typeof right === 'string') {\n        return right.indexOf(left) !== -1\n      }\n      if (Array.isArray(right)) {\n        return right.some(elem => elem === left)\n      }\n      return false\n    }\n  },\n  '!': {\n    type: 'unaryOp',\n    precedence: Infinity,\n    eval: right => !right\n  }\n}\n","/*\n * Jexl\n * Copyright 2019 Tom Shawver\n */\n\nconst Expression = require('./Expression')\nconst defaultGrammar = require('./grammar').elements\n\n/**\n * Jexl is the Javascript Expression Language, capable of parsing and\n * evaluating basic to complex expression strings, combined with advanced\n * xpath-like drilldown into native Javascript objects.\n * @constructor\n */\nclass Jexl {\n  constructor() {\n    // Allow expr to be called outside of the jexl context\n    this.expr = this.expr.bind(this)\n    this._grammar = Object.assign({}, defaultGrammar)\n    this._lexer = null\n    this._transforms = {}\n  }\n\n  /**\n   * Adds a binary operator to Jexl at the specified precedence. The higher the\n   * precedence, the earlier the operator is applied in the order of operations.\n   * For example, * has a higher precedence than +, because multiplication comes\n   * before division.\n   *\n   * Please see grammar.js for a listing of all default operators and their\n   * precedence values in order to choose the appropriate precedence for the\n   * new operator.\n   * @param {string} operator The operator string to be added\n   * @param {number} precedence The operator's precedence\n   * @param {function} fn A function to run to calculate the result. The function\n   *      will be called with two arguments: left and right, denoting the values\n   *      on either side of the operator. It should return either the resulting\n   *      value, or a Promise that resolves with the resulting value.\n   */\n  addBinaryOp(operator, precedence, fn) {\n    this._addGrammarElement(operator, {\n      type: 'binaryOp',\n      precedence: precedence,\n      eval: fn\n    })\n  }\n\n  /**\n   * Adds a unary operator to Jexl. Unary operators are currently only supported\n   * on the left side of the value on which it will operate.\n   * @param {string} operator The operator string to be added\n   * @param {function} fn A function to run to calculate the result. The function\n   *      will be called with one argument: the literal value to the right of the\n   *      operator. It should return either the resulting value, or a Promise\n   *      that resolves with the resulting value.\n   */\n  addUnaryOp(operator, fn) {\n    this._addGrammarElement(operator, {\n      type: 'unaryOp',\n      weight: Infinity,\n      eval: fn\n    })\n  }\n\n  /**\n   * Adds or replaces a transform function in this Jexl instance.\n   * @param {string} name The name of the transform function, as it will be used\n   *      within Jexl expressions\n   * @param {function} fn The function to be executed when this transform is\n   *      invoked. It will be provided with at least one argument:\n   *          - {*} value: The value to be transformed\n   *          - {...*} args: The arguments for this transform\n   */\n  addTransform(name, fn) {\n    this._transforms[name] = fn\n  }\n\n  /**\n   * Syntactic sugar for calling {@link #addTransform} repeatedly.  This function\n   * accepts a map of one or more transform names to their transform function.\n   * @param {{}} map A map of transform names to transform functions\n   */\n  addTransforms(map) {\n    for (let key in map) {\n      if (map.hasOwnProperty(key)) {\n        this._transforms[key] = map[key]\n      }\n    }\n  }\n\n  /**\n   * Creates an Expression object from the given Jexl expression string, and\n   * immediately compiles it. The returned Expression object can then be\n   * evaluated multiple times with new contexts, without generating any\n   * additional string processing overhead.\n   * @param {string} expression The Jexl expression to be compiled\n   * @returns {Expression} The compiled Expression object\n   */\n  compile(expression) {\n    const exprObj = this.createExpression(expression)\n    return exprObj.compile()\n  }\n\n  /**\n   * Constructs an Expression object from a Jexl expression string.\n   * @param {string} expression The Jexl expression to be wrapped in an\n   *    Expression object\n   * @returns {Expression} The Expression object representing the given string\n   */\n  createExpression(expression) {\n    const lang = this._getLang()\n    return new Expression(lang, expression)\n  }\n\n  /**\n   * Retrieves a previously set transform function.\n   * @param {string} name The name of the transform function\n   * @returns {function} The transform function\n   */\n  getTransform(name) {\n    return this._transforms[name]\n  }\n\n  /**\n   * Asynchronously evaluates a Jexl string within an optional context.\n   * @param {string} expression The Jexl expression to be evaluated\n   * @param {Object} [context] A mapping of variables to values, which will be\n   *      made accessible to the Jexl expression when evaluating it\n   * @returns {Promise<*>} resolves with the result of the evaluation.\n   */\n  eval(expression, context = {}) {\n    const exprObj = this.createExpression(expression)\n    return exprObj.eval(context)\n  }\n\n  /**\n   * Synchronously evaluates a Jexl string within an optional context.\n   * @param {string} expression The Jexl expression to be evaluated\n   * @param {Object} [context] A mapping of variables to values, which will be\n   *      made accessible to the Jexl expression when evaluating it\n   * @returns {*} the result of the evaluation.\n   * @throws {*} on error\n   */\n  evalSync(expression, context = {}) {\n    const exprObj = this.createExpression(expression)\n    return exprObj.evalSync(context)\n  }\n\n  expr(strs, ...args) {\n    const exprStr = strs.reduce((acc, str, idx) => {\n      const arg = idx < args.length ? args[idx] : ''\n      acc += str + arg\n      return acc\n    }, '')\n    return this.createExpression(exprStr)\n  }\n\n  /**\n   * Removes a binary or unary operator from the Jexl grammar.\n   * @param {string} operator The operator string to be removed\n   */\n  removeOp(operator) {\n    if (\n      this._grammar[operator] &&\n      (this._grammar[operator].type === 'binaryOp' ||\n        this._grammar[operator].type === 'unaryOp')\n    ) {\n      delete this._grammar[operator]\n    }\n  }\n\n  /**\n   * Adds an element to the grammar map used by this Jexl instance.\n   * @param {string} str The key string to be added\n   * @param {{type: <string>}} obj A map of configuration options for this\n   *      grammar element\n   * @private\n   */\n  _addGrammarElement(str, obj) {\n    this._grammar[str] = obj\n  }\n\n  /**\n   * Gets an object defining the dynamic language elements of this Jexl\n   * instance.\n   * @returns {{ grammar: object, transforms: object }} A language definition\n   *    object\n   * @private\n   */\n  _getLang() {\n    return {\n      grammar: this._grammar,\n      transforms: this._transforms\n    }\n  }\n}\n\nmodule.exports = new Jexl()\nmodule.exports.Jexl = Jexl\n","import * as jexl from 'jexl';\r\n\r\n\r\nexport default jexl.Jexl;\r\n"],"names":["h","states","require$$0","handlers","Lexer","Parser","PromiseSync","Evaluator","Expression","jexl.Jexl"],"mappings":"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"}