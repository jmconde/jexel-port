{"version":3,"file":"jexl.min.js","sources":["../node_modules/jexl/lib/evaluator/Evaluator.js","../node_modules/jexl/lib/evaluator/handlers.js","../node_modules/jexl/lib/Lexer.js","../node_modules/jexl/lib/parser/Parser.js","../node_modules/jexl/lib/parser/handlers.js","../node_modules/jexl/lib/parser/states.js","../node_modules/jexl/lib/PromiseSync.js","../node_modules/jexl/lib/Expression.js","../node_modules/jexl/lib/Jexl.js","../node_modules/jexl/lib/grammar.js"],"sourcesContent":["/*\n * Jexl\n * Copyright 2019 Tom Shawver\n */\n\nconst handlers = require('./handlers')\n\n/**\n * The Evaluator takes a Jexl expression tree as generated by the\n * {@link Parser} and calculates its value within a given context. The\n * collection of transforms, context, and a relative context to be used as the\n * root for relative identifiers, are all specific to an Evaluator instance.\n * When any of these things change, a new instance is required.  However, a\n * single instance can be used to simultaneously evaluate many different\n * expressions, and does not have to be reinstantiated for each.\n * @param {{}} grammar A grammar map against which to evaluate the expression\n *      tree\n * @param {{}} [transforms] A map of transform names to transform functions. A\n *      transform function takes two arguments:\n *          - {*} val: A value to be transformed\n *          - {{}} args: A map of argument keys to their evaluated values, as\n *              specified in the expression string\n *      The transform function should return either the transformed value, or\n *      a Promises/A+ Promise object that resolves with the value and rejects\n *      or throws only when an unrecoverable error occurs. Transforms should\n *      generally return undefined when they don't make sense to be used on the\n *      given value type, rather than throw/reject. An error is only\n *      appropriate when the transform would normally return a value, but\n *      cannot due to some other failure.\n * @param {{}} [context] A map of variable keys to their values. This will be\n *      accessed to resolve the value of each non-relative identifier. Any\n *      Promise values will be passed to the expression as their resolved\n *      value.\n * @param {{}|Array<{}|Array>} [relativeContext] A map or array to be accessed\n *      to resolve the value of a relative identifier.\n * @param {function} promise A constructor for the Promise class to be used;\n *      probably either Promise or PromiseSync.\n */\nclass Evaluator {\n  constructor(\n    grammar,\n    transforms,\n    context,\n    relativeContext,\n    promise = Promise\n  ) {\n    this._grammar = grammar\n    this._transforms = transforms || {}\n    this._context = context || {}\n    this._relContext = relativeContext || this._context\n    this.Promise = promise\n  }\n\n  /**\n   * Evaluates an expression tree within the configured context.\n   * @param {{}} ast An expression tree object\n   * @returns {Promise<*>} resolves with the resulting value of the expression.\n   */\n  eval(ast) {\n    return this.Promise.resolve().then(() => {\n      return handlers[ast.type].call(this, ast)\n    })\n  }\n\n  /**\n   * Simultaneously evaluates each expression within an array, and delivers the\n   * response as an array with the resulting values at the same indexes as their\n   * originating expressions.\n   * @param {Array<string>} arr An array of expression strings to be evaluated\n   * @returns {Promise<Array<{}>>} resolves with the result array\n   */\n  evalArray(arr) {\n    return this.Promise.all(arr.map(elem => this.eval(elem)))\n  }\n\n  /**\n   * Simultaneously evaluates each expression within a map, and delivers the\n   * response as a map with the same keys, but with the evaluated result for each\n   * as their value.\n   * @param {{}} map A map of expression names to expression trees to be\n   *      evaluated\n   * @returns {Promise<{}>} resolves with the result map.\n   */\n  evalMap(map) {\n    const keys = Object.keys(map)\n    const result = {}\n    const asts = keys.map(key => {\n      return this.eval(map[key])\n    })\n    return this.Promise.all(asts).then(vals => {\n      vals.forEach((val, idx) => {\n        result[keys[idx]] = val\n      })\n      return result\n    })\n  }\n\n  /**\n   * Applies a filter expression with relative identifier elements to a subject.\n   * The intent is for the subject to be an array of subjects that will be\n   * individually used as the relative context against the provided expression\n   * tree. Only the elements whose expressions result in a truthy value will be\n   * included in the resulting array.\n   *\n   * If the subject is not an array of values, it will be converted to a single-\n   * element array before running the filter.\n   * @param {*} subject The value to be filtered usually an array. If this value is\n   *      not an array, it will be converted to an array with this value as the\n   *      only element.\n   * @param {{}} expr The expression tree to run against each subject. If the\n   *      tree evaluates to a truthy result, then the value will be included in\n   *      the returned array otherwise, it will be eliminated.\n   * @returns {Promise<Array>} resolves with an array of values that passed the\n   *      expression filter.\n   * @private\n   */\n  _filterRelative(subject, expr) {\n    const promises = []\n    if (!Array.isArray(subject)) {\n      subject = subject === undefined ? [] : [subject]\n    }\n    subject.forEach(elem => {\n      const evalInst = new Evaluator(\n        this._grammar,\n        this._transforms,\n        this._context,\n        elem,\n        this.Promise\n      )\n      promises.push(evalInst.eval(expr))\n    })\n    return this.Promise.all(promises).then(values => {\n      const results = []\n      values.forEach((value, idx) => {\n        if (value) {\n          results.push(subject[idx])\n        }\n      })\n      return results\n    })\n  }\n\n  /**\n   * Applies a static filter expression to a subject value.  If the filter\n   * expression evaluates to boolean true, the subject is returned if false,\n   * undefined.\n   *\n   * For any other resulting value of the expression, this function will attempt\n   * to respond with the property at that name or index of the subject.\n   * @param {*} subject The value to be filtered.  Usually an Array (for which\n   *      the expression would generally resolve to a numeric index) or an\n   *      Object (for which the expression would generally resolve to a string\n   *      indicating a property name)\n   * @param {{}} expr The expression tree to run against the subject\n   * @returns {Promise<*>} resolves with the value of the drill-down.\n   * @private\n   */\n  _filterStatic(subject, expr) {\n    return this.eval(expr).then(res => {\n      if (typeof res === 'boolean') {\n        return res ? subject : undefined\n      }\n      return subject[res]\n    })\n  }\n}\n\nmodule.exports = Evaluator\n","/*\n * Jexl\n * Copyright 2019 Tom Shawver\n */\n\n/**\n * Evaluates an ArrayLiteral by returning its value, with each element\n * independently run through the evaluator.\n * @param {{type: 'ObjectLiteral', value: <{}>}} ast An expression tree with an\n *      ObjectLiteral as the top node\n * @returns {Promise.<[]>} resolves to a map contained evaluated values.\n * @private\n */\nexports.ArrayLiteral = function(ast) {\n  return this.evalArray(ast.value)\n}\n\n/**\n * Evaluates a BinaryExpression node by running the Grammar's evaluator for\n * the given operator.\n * @param {{type: 'BinaryExpression', operator: <string>, left: {},\n *      right: {}}} ast An expression tree with a BinaryExpression as the top\n *      node\n * @returns {Promise<*>} resolves with the value of the BinaryExpression.\n * @private\n */\nexports.BinaryExpression = function(ast) {\n  return this.Promise.all([this.eval(ast.left), this.eval(ast.right)]).then(\n    arr => this._grammar[ast.operator].eval(arr[0], arr[1])\n  )\n}\n\n/**\n * Evaluates a ConditionalExpression node by first evaluating its test branch,\n * and resolving with the consequent branch if the test is truthy, or the\n * alternate branch if it is not. If there is no consequent branch, the test\n * result will be used instead.\n * @param {{type: 'ConditionalExpression', test: {}, consequent: {},\n *      alternate: {}}} ast An expression tree with a ConditionalExpression as\n *      the top node\n * @private\n */\nexports.ConditionalExpression = function(ast) {\n  return this.eval(ast.test).then(res => {\n    if (res) {\n      if (ast.consequent) {\n        return this.eval(ast.consequent)\n      }\n      return res\n    }\n    return this.eval(ast.alternate)\n  })\n}\n\n/**\n * Evaluates a FilterExpression by applying it to the subject value.\n * @param {{type: 'FilterExpression', relative: <boolean>, expr: {},\n *      subject: {}}} ast An expression tree with a FilterExpression as the top\n *      node\n * @returns {Promise<*>} resolves with the value of the FilterExpression.\n * @private\n */\nexports.FilterExpression = function(ast) {\n  return this.eval(ast.subject).then(subject => {\n    if (ast.relative) {\n      return this._filterRelative(subject, ast.expr)\n    }\n    return this._filterStatic(subject, ast.expr)\n  })\n}\n\n/**\n * Evaluates an Identifier by either stemming from the evaluated 'from'\n * expression tree or accessing the context provided when this Evaluator was\n * constructed.\n * @param {{type: 'Identifier', value: <string>, [from]: {}}} ast An expression\n *      tree with an Identifier as the top node\n * @returns {Promise<*>|*} either the identifier's value, or a Promise that\n *      will resolve with the identifier's value.\n * @private\n */\nexports.Identifier = function(ast) {\n  if (!ast.from) {\n    return ast.relative ? this._relContext[ast.value] : this._context[ast.value]\n  }\n  return this.eval(ast.from).then(context => {\n    if (context === undefined || context === null) {\n      return undefined\n    }\n    if (Array.isArray(context)) {\n      context = context[0]\n    }\n    return context[ast.value]\n  })\n}\n\n/**\n * Evaluates a Literal by returning its value property.\n * @param {{type: 'Literal', value: <string|number|boolean>}} ast An expression\n *      tree with a Literal as its only node\n * @returns {string|number|boolean} The value of the Literal node\n * @private\n */\nexports.Literal = function(ast) {\n  return ast.value\n}\n\n/**\n * Evaluates an ObjectLiteral by returning its value, with each key\n * independently run through the evaluator.\n * @param {{type: 'ObjectLiteral', value: <{}>}} ast An expression tree with an\n *      ObjectLiteral as the top node\n * @returns {Promise<{}>} resolves to a map contained evaluated values.\n * @private\n */\nexports.ObjectLiteral = function(ast) {\n  return this.evalMap(ast.value)\n}\n\n/**\n * Evaluates a Transform node by applying a function from the transforms map\n * to the subject value.\n * @param {{type: 'Transform', name: <string>, subject: {}}} ast An\n *      expression tree with a Transform as the top node\n * @returns {Promise<*>|*} the value of the transformation, or a Promise that\n *      will resolve with the transformed value.\n * @private\n */\nexports.Transform = function(ast) {\n  const transform = this._transforms[ast.name]\n  if (!transform) {\n    throw new Error(`Transform ${ast.name} is not defined.`)\n  }\n  return this.Promise.all([\n    this.eval(ast.subject),\n    this.evalArray(ast.args || [])\n  ]).then(arr => transform.apply(null, [arr[0]].concat(arr[1])))\n}\n\n/**\n * Evaluates a Unary expression by passing the right side through the\n * operator's eval function.\n * @param {{type: 'UnaryExpression', operator: <string>, right: {}}} ast An\n *      expression tree with a UnaryExpression as the top node\n * @returns {Promise<*>} resolves with the value of the UnaryExpression.\n * @constructor\n */\nexports.UnaryExpression = function(ast) {\n  return this.eval(ast.right).then(right =>\n    this._grammar[ast.operator].eval(right)\n  )\n}\n","/*\n * Jexl\n * Copyright 2019 Tom Shawver\n */\n\nconst numericRegex = /^-?(?:(?:[0-9]*\\.[0-9]+)|[0-9]+)$/\nconst identRegex = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/\nconst escEscRegex = /\\\\\\\\/\nconst whitespaceRegex = /^\\s*$/\nconst preOpRegexElems = [\n  // Strings\n  \"'(?:(?:\\\\\\\\')|[^'])*'\",\n  '\"(?:(?:\\\\\\\\\")|[^\"])*\"',\n  // Whitespace\n  '\\\\s+',\n  // Booleans\n  '\\\\btrue\\\\b',\n  '\\\\bfalse\\\\b'\n]\nconst postOpRegexElems = [\n  // Identifiers\n  '[a-zA-Z_\\\\$][a-zA-Z0-9_\\\\$]*',\n  // Numerics (without negative symbol)\n  '(?:(?:[0-9]*\\\\.[0-9]+)|[0-9]+)'\n]\nconst minusNegatesAfter = [\n  'binaryOp',\n  'unaryOp',\n  'openParen',\n  'openBracket',\n  'question',\n  'colon'\n]\n\n/**\n * Lexer is a collection of stateless, statically-accessed functions for the\n * lexical parsing of a Jexl string.  Its responsibility is to identify the\n * \"parts of speech\" of a Jexl expression, and tokenize and label each, but\n * to do only the most minimal syntax checking; the only errors the Lexer\n * should be concerned with are if it's unable to identify the utility of\n * any of its tokens.  Errors stemming from these tokens not being in a\n * sensible configuration should be left for the Parser to handle.\n * @type {{}}\n */\nclass Lexer {\n  constructor(grammar) {\n    this._grammar = grammar\n  }\n\n  /**\n   * Splits a Jexl expression string into an array of expression elements.\n   * @param {string} str A Jexl expression string\n   * @returns {Array<string>} An array of substrings defining the functional\n   *      elements of the expression.\n   */\n  getElements(str) {\n    const regex = this._getSplitRegex()\n    return str.split(regex).filter(elem => {\n      // Remove empty strings\n      return elem\n    })\n  }\n\n  /**\n   * Converts an array of expression elements into an array of tokens.  Note that\n   * the resulting array may not equal the element array in length, as any\n   * elements that consist only of whitespace get appended to the previous\n   * token's \"raw\" property.  For the structure of a token object, please see\n   * {@link Lexer#tokenize}.\n   * @param {Array<string>} elements An array of Jexl expression elements to be\n   *      converted to tokens\n   * @returns {Array<{type, value, raw}>} an array of token objects.\n   */\n  getTokens(elements) {\n    const tokens = []\n    let negate = false\n    for (let i = 0; i < elements.length; i++) {\n      if (this._isWhitespace(elements[i])) {\n        if (tokens.length) {\n          tokens[tokens.length - 1].raw += elements[i]\n        }\n      } else if (elements[i] === '-' && this._isNegative(tokens)) {\n        negate = true\n      } else {\n        if (negate) {\n          elements[i] = '-' + elements[i]\n          negate = false\n        }\n        tokens.push(this._createToken(elements[i]))\n      }\n    }\n    // Catch a - at the end of the string. Let the parser handle that issue.\n    if (negate) {\n      tokens.push(this._createToken('-'))\n    }\n    return tokens\n  }\n\n  /**\n   * Converts a Jexl string into an array of tokens.  Each token is an object\n   * in the following format:\n   *\n   *     {\n   *         type: <string>,\n   *         [name]: <string>,\n   *         value: <boolean|number|string>,\n   *         raw: <string>\n   *     }\n   *\n   * Type is one of the following:\n   *\n   *      literal, identifier, binaryOp, unaryOp\n   *\n   * OR, if the token is a control character its type is the name of the element\n   * defined in the Grammar.\n   *\n   * Name appears only if the token is a control string found in\n   * {@link grammar#elements}, and is set to the name of the element.\n   *\n   * Value is the value of the token in the correct type (boolean or numeric as\n   * appropriate). Raw is the string representation of this value taken directly\n   * from the expression string, including any trailing spaces.\n   * @param {string} str The Jexl string to be tokenized\n   * @returns {Array<{type, value, raw}>} an array of token objects.\n   * @throws {Error} if the provided string contains an invalid token.\n   */\n  tokenize(str) {\n    const elements = this.getElements(str)\n    return this.getTokens(elements)\n  }\n\n  /**\n   * Creates a new token object from an element of a Jexl string. See\n   * {@link Lexer#tokenize} for a description of the token object.\n   * @param {string} element The element from which a token should be made\n   * @returns {{value: number|boolean|string, [name]: string, type: string,\n   *      raw: string}} a token object describing the provided element.\n   * @throws {Error} if the provided string is not a valid expression element.\n   * @private\n   */\n  _createToken(element) {\n    const token = {\n      type: 'literal',\n      value: element,\n      raw: element\n    }\n    if (element[0] === '\"' || element[0] === \"'\") {\n      token.value = this._unquote(element)\n    } else if (element.match(numericRegex)) {\n      token.value = parseFloat(element)\n    } else if (element === 'true' || element === 'false') {\n      token.value = element === 'true'\n    } else if (this._grammar[element]) {\n      token.type = this._grammar[element].type\n    } else if (element.match(identRegex)) {\n      token.type = 'identifier'\n    } else {\n      throw new Error(`Invalid expression token: ${element}`)\n    }\n    return token\n  }\n\n  /**\n   * Escapes a string so that it can be treated as a string literal within a\n   * regular expression.\n   * @param {string} str The string to be escaped\n   * @returns {string} the RegExp-escaped string.\n   * @see https://developer.mozilla.org/en/docs/Web/JavaScript/Guide/Regular_Expressions\n   * @private\n   */\n  _escapeRegExp(str) {\n    str = str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n    if (str.match(identRegex)) {\n      str = '\\\\b' + str + '\\\\b'\n    }\n    return str\n  }\n\n  /**\n   * Gets a RegEx object appropriate for splitting a Jexl string into its core\n   * elements.\n   * @returns {RegExp} An element-splitting RegExp object\n   * @private\n   */\n  _getSplitRegex() {\n    if (!this._splitRegex) {\n      // Sort by most characters to least, then regex escape each\n      const elemArray = Object.keys(this._grammar)\n        .sort((a, b) => {\n          return b.length - a.length\n        })\n        .map(elem => {\n          return this._escapeRegExp(elem)\n        }, this)\n      this._splitRegex = new RegExp(\n        '(' +\n          [\n            preOpRegexElems.join('|'),\n            elemArray.join('|'),\n            postOpRegexElems.join('|')\n          ].join('|') +\n          ')'\n      )\n    }\n    return this._splitRegex\n  }\n\n  /**\n   * Determines whether the addition of a '-' token should be interpreted as a\n   * negative symbol for an upcoming number, given an array of tokens already\n   * processed.\n   * @param {Array<Object>} tokens An array of tokens already processed\n   * @returns {boolean} true if adding a '-' should be considered a negative\n   *      symbol; false otherwise\n   * @private\n   */\n  _isNegative(tokens) {\n    if (!tokens.length) return true\n    return minusNegatesAfter.some(\n      type => type === tokens[tokens.length - 1].type\n    )\n  }\n\n  /**\n   * A utility function to determine if a string consists of only space\n   * characters.\n   * @param {string} str A string to be tested\n   * @returns {boolean} true if the string is empty or consists of only spaces;\n   *      false otherwise.\n   * @private\n   */\n  _isWhitespace(str) {\n    return !!str.match(whitespaceRegex)\n  }\n\n  /**\n   * Removes the beginning and trailing quotes from a string, unescapes any\n   * escaped quotes on its interior, and unescapes any escaped escape\n   * characters. Note that this function is not defensive; it assumes that the\n   * provided string is not empty, and that its first and last characters are\n   * actually quotes.\n   * @param {string} str A string whose first and last characters are quotes\n   * @returns {string} a string with the surrounding quotes stripped and escapes\n   *      properly processed.\n   * @private\n   */\n  _unquote(str) {\n    const quote = str[0]\n    const escQuoteRegex = new RegExp('\\\\\\\\' + quote, 'g')\n    return str\n      .substr(1, str.length - 2)\n      .replace(escQuoteRegex, quote)\n      .replace(escEscRegex, '\\\\')\n  }\n}\n\nmodule.exports = Lexer\n","/*\n * Jexl\n * Copyright 2019 Tom Shawver\n */\n\nconst handlers = require('./handlers')\nconst states = require('./states').states\n\n/**\n * The Parser is a state machine that converts tokens from the {@link Lexer}\n * into an Abstract Syntax Tree (AST), capable of being evaluated in any\n * context by the {@link Evaluator}.  The Parser expects that all tokens\n * provided to it are legal and typed properly according to the grammar, but\n * accepts that the tokens may still be in an invalid order or in some other\n * unparsable configuration that requires it to throw an Error.\n * @param {{}} grammar The grammar map to use to parse Jexl strings\n * @param {string} [prefix] A string prefix to prepend to the expression string\n *      for error messaging purposes.  This is useful for when a new Parser is\n *      instantiated to parse an subexpression, as the parent Parser's\n *      expression string thus far can be passed for a more user-friendly\n *      error message.\n * @param {{}} [stopMap] A mapping of token types to any truthy value. When the\n *      token type is encountered, the parser will return the mapped value\n *      instead of boolean false.\n */\nclass Parser {\n  constructor(grammar, prefix, stopMap) {\n    this._grammar = grammar\n    this._state = 'expectOperand'\n    this._tree = null\n    this._exprStr = prefix || ''\n    this._relative = false\n    this._stopMap = stopMap || {}\n  }\n\n  /**\n   * Processes a new token into the AST and manages the transitions of the state\n   * machine.\n   * @param {{type: <string>}} token A token object, as provided by the\n   *      {@link Lexer#tokenize} function.\n   * @throws {Error} if a token is added when the Parser has been marked as\n   *      complete by {@link #complete}, or if an unexpected token type is added.\n   * @returns {boolean|*} the stopState value if this parser encountered a token\n   *      in the stopState mapb false if tokens can continue.\n   */\n  addToken(token) {\n    if (this._state === 'complete') {\n      throw new Error('Cannot add a new token to a completed Parser')\n    }\n    const state = states[this._state]\n    const startExpr = this._exprStr\n    this._exprStr += token.raw\n    if (state.subHandler) {\n      if (!this._subParser) {\n        this._startSubExpression(startExpr)\n      }\n      const stopState = this._subParser.addToken(token)\n      if (stopState) {\n        this._endSubExpression()\n        if (this._parentStop) return stopState\n        this._state = stopState\n      }\n    } else if (state.tokenTypes[token.type]) {\n      const typeOpts = state.tokenTypes[token.type]\n      let handleFunc = handlers[token.type]\n      if (typeOpts.handler) {\n        handleFunc = typeOpts.handler\n      }\n      if (handleFunc) {\n        handleFunc.call(this, token)\n      }\n      if (typeOpts.toState) {\n        this._state = typeOpts.toState\n      }\n    } else if (this._stopMap[token.type]) {\n      return this._stopMap[token.type]\n    } else {\n      throw new Error(\n        `Token ${token.raw} (${token.type}) unexpected in expression: ${this._exprStr}`\n      )\n    }\n    return false\n  }\n\n  /**\n   * Processes an array of tokens iteratively through the {@link #addToken}\n   * function.\n   * @param {Array<{type: <string>}>} tokens An array of tokens, as provided by\n   *      the {@link Lexer#tokenize} function.\n   */\n  addTokens(tokens) {\n    tokens.forEach(this.addToken, this)\n  }\n\n  /**\n   * Marks this Parser instance as completed and retrieves the full AST.\n   * @returns {{}|null} a full expression tree, ready for evaluation by the\n   *      {@link Evaluator#eval} function, or null if no tokens were passed to\n   *      the parser before complete was called\n   * @throws {Error} if the parser is not in a state where it's legal to end\n   *      the expression, indicating that the expression is incomplete\n   */\n  complete() {\n    if (this._cursor && !states[this._state].completable) {\n      throw new Error(`Unexpected end of expression: ${this._exprStr}`)\n    }\n    if (this._subParser) {\n      this._endSubExpression()\n    }\n    this._state = 'complete'\n    return this._cursor ? this._tree : null\n  }\n\n  /**\n   * Indicates whether the expression tree contains a relative path identifier.\n   * @returns {boolean} true if a relative identifier exists false otherwise.\n   */\n  isRelative() {\n    return this._relative\n  }\n\n  /**\n   * Ends a subexpression by completing the subParser and passing its result\n   * to the subHandler configured in the current state.\n   * @private\n   */\n  _endSubExpression() {\n    states[this._state].subHandler.call(this, this._subParser.complete())\n    this._subParser = null\n  }\n\n  /**\n   * Places a new tree node at the current position of the cursor (to the 'right'\n   * property) and then advances the cursor to the new node. This function also\n   * handles setting the parent of the new node.\n   * @param {{type: <string>}} node A node to be added to the AST\n   * @private\n   */\n  _placeAtCursor(node) {\n    if (!this._cursor) {\n      this._tree = node\n    } else {\n      this._cursor.right = node\n      this._setParent(node, this._cursor)\n    }\n    this._cursor = node\n  }\n\n  /**\n   * Places a tree node before the current position of the cursor, replacing\n   * the node that the cursor currently points to. This should only be called in\n   * cases where the cursor is known to exist, and the provided node already\n   * contains a pointer to what's at the cursor currently.\n   * @param {{type: <string>}} node A node to be added to the AST\n   * @private\n   */\n  _placeBeforeCursor(node) {\n    this._cursor = this._cursor._parent\n    this._placeAtCursor(node)\n  }\n\n  /**\n   * Sets the parent of a node by creating a non-enumerable _parent property\n   * that points to the supplied parent argument.\n   * @param {{type: <string>}} node A node of the AST on which to set a new\n   *      parent\n   * @param {{type: <string>}} parent An existing node of the AST to serve as the\n   *      parent of the new node\n   * @private\n   */\n  _setParent(node, parent) {\n    Object.defineProperty(node, '_parent', {\n      value: parent,\n      writable: true\n    })\n  }\n\n  /**\n   * Prepares the Parser to accept a subexpression by (re)instantiating the\n   * subParser.\n   * @param {string} [exprStr] The expression string to prefix to the new Parser\n   * @private\n   */\n  _startSubExpression(exprStr) {\n    let endStates = states[this._state].endStates\n    if (!endStates) {\n      this._parentStop = true\n      endStates = this._stopMap\n    }\n    this._subParser = new Parser(this._grammar, exprStr, endStates)\n  }\n}\n\nmodule.exports = Parser\n","/*\n * Jexl\n * Copyright 2019 Tom Shawver\n */\n\n/**\n * Handles a subexpression that's used to define a transform argument's value.\n * @param {{type: <string>}} ast The subexpression tree\n */\nexports.argVal = function(ast) {\n  this._cursor.args.push(ast)\n}\n\n/**\n * Handles new array literals by adding them as a new node in the AST,\n * initialized with an empty array.\n */\nexports.arrayStart = function() {\n  this._placeAtCursor({\n    type: 'ArrayLiteral',\n    value: []\n  })\n}\n\n/**\n * Handles a subexpression representing an element of an array literal.\n * @param {{type: <string>}} ast The subexpression tree\n */\nexports.arrayVal = function(ast) {\n  if (ast) {\n    this._cursor.value.push(ast)\n  }\n}\n\n/**\n * Handles tokens of type 'binaryOp', indicating an operation that has two\n * inputs: a left side and a right side.\n * @param {{type: <string>}} token A token object\n */\nexports.binaryOp = function(token) {\n  const precedence = this._grammar[token.value].precedence || 0\n  let parent = this._cursor._parent\n  while (\n    parent &&\n    parent.operator &&\n    this._grammar[parent.operator].precedence >= precedence\n  ) {\n    this._cursor = parent\n    parent = parent._parent\n  }\n  const node = {\n    type: 'BinaryExpression',\n    operator: token.value,\n    left: this._cursor\n  }\n  this._setParent(this._cursor, node)\n  this._cursor = parent\n  this._placeAtCursor(node)\n}\n\n/**\n * Handles successive nodes in an identifier chain.  More specifically, it\n * sets values that determine how the following identifier gets placed in the\n * AST.\n */\nexports.dot = function() {\n  this._nextIdentEncapsulate =\n    this._cursor &&\n    this._cursor.type !== 'UnaryExpression' &&\n    (this._cursor.type !== 'BinaryExpression' ||\n      (this._cursor.type === 'BinaryExpression' && this._cursor.right))\n  this._nextIdentRelative =\n    !this._cursor || (this._cursor && !this._nextIdentEncapsulate)\n  if (this._nextIdentRelative) {\n    this._relative = true\n  }\n}\n\n/**\n * Handles a subexpression used for filtering an array returned by an\n * identifier chain.\n * @param {{type: <string>}} ast The subexpression tree\n */\nexports.filter = function(ast) {\n  this._placeBeforeCursor({\n    type: 'FilterExpression',\n    expr: ast,\n    relative: this._subParser.isRelative(),\n    subject: this._cursor\n  })\n}\n\n/**\n * Handles identifier tokens by adding them as a new node in the AST.\n * @param {{type: <string>}} token A token object\n */\nexports.identifier = function(token) {\n  const node = {\n    type: 'Identifier',\n    value: token.value\n  }\n  if (this._nextIdentEncapsulate) {\n    node.from = this._cursor\n    this._placeBeforeCursor(node)\n    this._nextIdentEncapsulate = false\n  } else {\n    if (this._nextIdentRelative) {\n      node.relative = true\n      this._nextIdentRelative = false\n    }\n    this._placeAtCursor(node)\n  }\n}\n\n/**\n * Handles literal values, such as strings, booleans, and numerics, by adding\n * them as a new node in the AST.\n * @param {{type: <string>}} token A token object\n */\nexports.literal = function(token) {\n  this._placeAtCursor({\n    type: 'Literal',\n    value: token.value\n  })\n}\n\n/**\n * Queues a new object literal key to be written once a value is collected.\n * @param {{type: <string>}} token A token object\n */\nexports.objKey = function(token) {\n  this._curObjKey = token.value\n}\n\n/**\n * Handles new object literals by adding them as a new node in the AST,\n * initialized with an empty object.\n */\nexports.objStart = function() {\n  this._placeAtCursor({\n    type: 'ObjectLiteral',\n    value: {}\n  })\n}\n\n/**\n * Handles an object value by adding its AST to the queued key on the object\n * literal node currently at the cursor.\n * @param {{type: <string>}} ast The subexpression tree\n */\nexports.objVal = function(ast) {\n  this._cursor.value[this._curObjKey] = ast\n}\n\n/**\n * Handles traditional subexpressions, delineated with the groupStart and\n * groupEnd elements.\n * @param {{type: <string>}} ast The subexpression tree\n */\nexports.subExpression = function(ast) {\n  this._placeAtCursor(ast)\n}\n\n/**\n * Handles a completed alternate subexpression of a ternary operator.\n * @param {{type: <string>}} ast The subexpression tree\n */\nexports.ternaryEnd = function(ast) {\n  this._cursor.alternate = ast\n}\n\n/**\n * Handles a completed consequent subexpression of a ternary operator.\n * @param {{type: <string>}} ast The subexpression tree\n */\nexports.ternaryMid = function(ast) {\n  this._cursor.consequent = ast\n}\n\n/**\n * Handles the start of a new ternary expression by encapsulating the entire\n * AST in a ConditionalExpression node, and using the existing tree as the\n * test element.\n */\nexports.ternaryStart = function() {\n  this._tree = {\n    type: 'ConditionalExpression',\n    test: this._tree\n  }\n  this._cursor = this._tree\n}\n\n/**\n * Handles identifier tokens when used to indicate the name of a transform to\n * be applied.\n * @param {{type: <string>}} token A token object\n */\nexports.transform = function(token) {\n  this._placeBeforeCursor({\n    type: 'Transform',\n    name: token.value,\n    args: [],\n    subject: this._cursor\n  })\n}\n\n/**\n * Handles token of type 'unaryOp', indicating that the operation has only\n * one input: a right side.\n * @param {{type: <string>}} token A token object\n */\nexports.unaryOp = function(token) {\n  this._placeAtCursor({\n    type: 'UnaryExpression',\n    operator: token.value\n  })\n}\n","/*\n * Jexl\n * Copyright 2019 Tom Shawver\n */\n\nconst h = require('./handlers')\n\n/**\n * A mapping of all states in the finite state machine to a set of instructions\n * for handling or transitioning into other states. Each state can be handled\n * in one of two schemes: a tokenType map, or a subHandler.\n *\n * Standard expression elements are handled through the tokenType object. This\n * is an object map of all legal token types to encounter in this state (and\n * any unexpected token types will generate a thrown error) to an options\n * object that defines how they're handled.  The available options are:\n *\n *      {string} toState: The name of the state to which to transition\n *          immediately after handling this token\n *      {string} handler: The handler function to call when this token type is\n *          encountered in this state.  If omitted, the default handler\n *          matching the token's \"type\" property will be called. If the handler\n *          function does not exist, no call will be made and no error will be\n *          generated.  This is useful for tokens whose sole purpose is to\n *          transition to other states.\n *\n * States that consume a subexpression should define a subHandler, the\n * function to be called with an expression tree argument when the\n * subexpression is complete. Completeness is determined through the\n * endStates object, which maps tokens on which an expression should end to the\n * state to which to transition once the subHandler function has been called.\n *\n * Additionally, any state in which it is legal to mark the AST as completed\n * should have a 'completable' property set to boolean true.  Attempting to\n * call {@link Parser#complete} in any state without this property will result\n * in a thrown Error.\n *\n * @type {{}}\n */\nexports.states = {\n  expectOperand: {\n    tokenTypes: {\n      literal: { toState: 'expectBinOp' },\n      identifier: { toState: 'identifier' },\n      unaryOp: {},\n      openParen: { toState: 'subExpression' },\n      openCurl: { toState: 'expectObjKey', handler: h.objStart },\n      dot: { toState: 'traverse' },\n      openBracket: { toState: 'arrayVal', handler: h.arrayStart }\n    }\n  },\n  expectBinOp: {\n    tokenTypes: {\n      binaryOp: { toState: 'expectOperand' },\n      pipe: { toState: 'expectTransform' },\n      dot: { toState: 'traverse' },\n      question: { toState: 'ternaryMid', handler: h.ternaryStart }\n    },\n    completable: true\n  },\n  expectTransform: {\n    tokenTypes: {\n      identifier: { toState: 'postTransform', handler: h.transform }\n    }\n  },\n  expectObjKey: {\n    tokenTypes: {\n      identifier: { toState: 'expectKeyValSep', handler: h.objKey },\n      closeCurl: { toState: 'expectBinOp' }\n    }\n  },\n  expectKeyValSep: {\n    tokenTypes: {\n      colon: { toState: 'objVal' }\n    }\n  },\n  postTransform: {\n    tokenTypes: {\n      openParen: { toState: 'argVal' },\n      binaryOp: { toState: 'expectOperand' },\n      dot: { toState: 'traverse' },\n      openBracket: { toState: 'filter' },\n      pipe: { toState: 'expectTransform' }\n    },\n    completable: true\n  },\n  postTransformArgs: {\n    tokenTypes: {\n      binaryOp: { toState: 'expectOperand' },\n      dot: { toState: 'traverse' },\n      openBracket: { toState: 'filter' },\n      pipe: { toState: 'expectTransform' }\n    },\n    completable: true\n  },\n  identifier: {\n    tokenTypes: {\n      binaryOp: { toState: 'expectOperand' },\n      dot: { toState: 'traverse' },\n      openBracket: { toState: 'filter' },\n      pipe: { toState: 'expectTransform' },\n      question: { toState: 'ternaryMid', handler: h.ternaryStart }\n    },\n    completable: true\n  },\n  traverse: {\n    tokenTypes: {\n      identifier: { toState: 'identifier' }\n    }\n  },\n  filter: {\n    subHandler: h.filter,\n    endStates: {\n      closeBracket: 'identifier'\n    }\n  },\n  subExpression: {\n    subHandler: h.subExpression,\n    endStates: {\n      closeParen: 'expectBinOp'\n    }\n  },\n  argVal: {\n    subHandler: h.argVal,\n    endStates: {\n      comma: 'argVal',\n      closeParen: 'postTransformArgs'\n    }\n  },\n  objVal: {\n    subHandler: h.objVal,\n    endStates: {\n      comma: 'expectObjKey',\n      closeCurl: 'expectBinOp'\n    }\n  },\n  arrayVal: {\n    subHandler: h.arrayVal,\n    endStates: {\n      comma: 'arrayVal',\n      closeBracket: 'expectBinOp'\n    }\n  },\n  ternaryMid: {\n    subHandler: h.ternaryMid,\n    endStates: {\n      colon: 'ternaryEnd'\n    }\n  },\n  ternaryEnd: {\n    subHandler: h.ternaryEnd,\n    completable: true\n  }\n}\n","/*\n * Jexl\n * Copyright 2019 Tom Shawver\n */\n\nclass PromiseSync {\n  constructor(fn) {\n    fn(this._resolve.bind(this), this._reject.bind(this))\n  }\n\n  catch(rejected) {\n    if (this.error) {\n      try {\n        this._resolve(rejected(this.error))\n      } catch (e) {\n        this._reject(e)\n      }\n    }\n    return this\n  }\n\n  then(resolved, rejected) {\n    if (!this.error) {\n      try {\n        this._resolve(resolved(this.value))\n      } catch (e) {\n        this._reject(e)\n      }\n    }\n    if (rejected) this.catch(rejected)\n    return this\n  }\n\n  _reject(error) {\n    this.value = undefined\n    this.error = error\n  }\n\n  _resolve(val) {\n    if (val instanceof PromiseSync) {\n      if (val.error) {\n        this._reject(val.error)\n      } else {\n        this._resolve(val.value)\n      }\n    } else {\n      this.value = val\n      this.error = undefined\n    }\n  }\n}\n\nPromiseSync.all = vals =>\n  new PromiseSync(resolve => {\n    const resolved = vals.map(val => {\n      while (val instanceof PromiseSync) {\n        if (val.error) throw Error(val.error)\n        val = val.value\n      }\n      return val\n    })\n    resolve(resolved)\n  })\n\nPromiseSync.resolve = val => new PromiseSync(resolve => resolve(val))\n\nPromiseSync.reject = error =>\n  new PromiseSync((resolve, reject) => reject(error))\n\nmodule.exports = PromiseSync\n","/*\n * Jexl\n * Copyright 2019 Tom Shawver\n */\n\nconst Evaluator = require('./evaluator/Evaluator')\nconst Lexer = require('./Lexer')\nconst Parser = require('./parser/Parser')\nconst PromiseSync = require('./PromiseSync')\n\nclass Expression {\n  constructor(lang, exprStr) {\n    this._lang = lang\n    this._lexer = new Lexer(lang.grammar)\n    this._exprStr = exprStr\n    this._ast = null\n  }\n\n  /**\n   * Forces a compilation of the expression string that this Expression object\n   * was constructed with. This function can be called multiple times; useful\n   * if the language elements of the associated Jexl instance change.\n   * @returns {Expression} this Expression instance, for convenience\n   */\n  compile() {\n    const lexer = new Lexer(this._lang.grammar)\n    const parser = new Parser(this._lang.grammar)\n    const tokens = lexer.tokenize(this._exprStr)\n    parser.addTokens(tokens)\n    this._ast = parser.complete()\n    return this\n  }\n\n  /**\n   * Asynchronously evaluates the expression within an optional context.\n   * @param {Object} [context] A mapping of variables to values, which will be\n   *      made accessible to the Jexl expression when evaluating it\n   * @returns {Promise<*>} resolves with the result of the evaluation.\n   */\n  eval(context = {}) {\n    return this._eval(context, Promise)\n  }\n\n  /**\n   * Synchronously evaluates the expression within an optional context.\n   * @param {Object} [context] A mapping of variables to values, which will be\n   *      made accessible to the Jexl expression when evaluating it\n   * @returns {*} the result of the evaluation.\n   * @throws {*} on error\n   */\n  evalSync(context = {}) {\n    const res = this._eval(context, PromiseSync)\n    if (res.error) throw res.error\n    return res.value\n  }\n\n  _eval(context, promise) {\n    return promise.resolve().then(() => {\n      const ast = this._getAst()\n      const evaluator = new Evaluator(\n        this._lang.grammar,\n        this._lang.transforms,\n        context,\n        undefined,\n        promise\n      )\n      return evaluator.eval(ast)\n    })\n  }\n\n  _getAst() {\n    if (!this._ast) this.compile()\n    return this._ast\n  }\n}\n\nmodule.exports = Expression\n","/*\n * Jexl\n * Copyright 2019 Tom Shawver\n */\n\nconst Expression = require('./Expression')\nconst defaultGrammar = require('./grammar').elements\n\n/**\n * Jexl is the Javascript Expression Language, capable of parsing and\n * evaluating basic to complex expression strings, combined with advanced\n * xpath-like drilldown into native Javascript objects.\n * @constructor\n */\nclass Jexl {\n  constructor() {\n    // Allow expr to be called outside of the jexl context\n    this.expr = this.expr.bind(this)\n    this._grammar = Object.assign({}, defaultGrammar)\n    this._lexer = null\n    this._transforms = {}\n  }\n\n  /**\n   * Adds a binary operator to Jexl at the specified precedence. The higher the\n   * precedence, the earlier the operator is applied in the order of operations.\n   * For example, * has a higher precedence than +, because multiplication comes\n   * before division.\n   *\n   * Please see grammar.js for a listing of all default operators and their\n   * precedence values in order to choose the appropriate precedence for the\n   * new operator.\n   * @param {string} operator The operator string to be added\n   * @param {number} precedence The operator's precedence\n   * @param {function} fn A function to run to calculate the result. The function\n   *      will be called with two arguments: left and right, denoting the values\n   *      on either side of the operator. It should return either the resulting\n   *      value, or a Promise that resolves with the resulting value.\n   */\n  addBinaryOp(operator, precedence, fn) {\n    this._addGrammarElement(operator, {\n      type: 'binaryOp',\n      precedence: precedence,\n      eval: fn\n    })\n  }\n\n  /**\n   * Adds a unary operator to Jexl. Unary operators are currently only supported\n   * on the left side of the value on which it will operate.\n   * @param {string} operator The operator string to be added\n   * @param {function} fn A function to run to calculate the result. The function\n   *      will be called with one argument: the literal value to the right of the\n   *      operator. It should return either the resulting value, or a Promise\n   *      that resolves with the resulting value.\n   */\n  addUnaryOp(operator, fn) {\n    this._addGrammarElement(operator, {\n      type: 'unaryOp',\n      weight: Infinity,\n      eval: fn\n    })\n  }\n\n  /**\n   * Adds or replaces a transform function in this Jexl instance.\n   * @param {string} name The name of the transform function, as it will be used\n   *      within Jexl expressions\n   * @param {function} fn The function to be executed when this transform is\n   *      invoked. It will be provided with at least one argument:\n   *          - {*} value: The value to be transformed\n   *          - {...*} args: The arguments for this transform\n   */\n  addTransform(name, fn) {\n    this._transforms[name] = fn\n  }\n\n  /**\n   * Syntactic sugar for calling {@link #addTransform} repeatedly.  This function\n   * accepts a map of one or more transform names to their transform function.\n   * @param {{}} map A map of transform names to transform functions\n   */\n  addTransforms(map) {\n    for (let key in map) {\n      if (map.hasOwnProperty(key)) {\n        this._transforms[key] = map[key]\n      }\n    }\n  }\n\n  /**\n   * Creates an Expression object from the given Jexl expression string, and\n   * immediately compiles it. The returned Expression object can then be\n   * evaluated multiple times with new contexts, without generating any\n   * additional string processing overhead.\n   * @param {string} expression The Jexl expression to be compiled\n   * @returns {Expression} The compiled Expression object\n   */\n  compile(expression) {\n    const exprObj = this.createExpression(expression)\n    return exprObj.compile()\n  }\n\n  /**\n   * Constructs an Expression object from a Jexl expression string.\n   * @param {string} expression The Jexl expression to be wrapped in an\n   *    Expression object\n   * @returns {Expression} The Expression object representing the given string\n   */\n  createExpression(expression) {\n    const lang = this._getLang()\n    return new Expression(lang, expression)\n  }\n\n  /**\n   * Retrieves a previously set transform function.\n   * @param {string} name The name of the transform function\n   * @returns {function} The transform function\n   */\n  getTransform(name) {\n    return this._transforms[name]\n  }\n\n  /**\n   * Asynchronously evaluates a Jexl string within an optional context.\n   * @param {string} expression The Jexl expression to be evaluated\n   * @param {Object} [context] A mapping of variables to values, which will be\n   *      made accessible to the Jexl expression when evaluating it\n   * @returns {Promise<*>} resolves with the result of the evaluation.\n   */\n  eval(expression, context = {}) {\n    const exprObj = this.createExpression(expression)\n    return exprObj.eval(context)\n  }\n\n  /**\n   * Synchronously evaluates a Jexl string within an optional context.\n   * @param {string} expression The Jexl expression to be evaluated\n   * @param {Object} [context] A mapping of variables to values, which will be\n   *      made accessible to the Jexl expression when evaluating it\n   * @returns {*} the result of the evaluation.\n   * @throws {*} on error\n   */\n  evalSync(expression, context = {}) {\n    const exprObj = this.createExpression(expression)\n    return exprObj.evalSync(context)\n  }\n\n  expr(strs, ...args) {\n    const exprStr = strs.reduce((acc, str, idx) => {\n      const arg = idx < args.length ? args[idx] : ''\n      acc += str + arg\n      return acc\n    }, '')\n    return this.createExpression(exprStr)\n  }\n\n  /**\n   * Removes a binary or unary operator from the Jexl grammar.\n   * @param {string} operator The operator string to be removed\n   */\n  removeOp(operator) {\n    if (\n      this._grammar[operator] &&\n      (this._grammar[operator].type === 'binaryOp' ||\n        this._grammar[operator].type === 'unaryOp')\n    ) {\n      delete this._grammar[operator]\n    }\n  }\n\n  /**\n   * Adds an element to the grammar map used by this Jexl instance.\n   * @param {string} str The key string to be added\n   * @param {{type: <string>}} obj A map of configuration options for this\n   *      grammar element\n   * @private\n   */\n  _addGrammarElement(str, obj) {\n    this._grammar[str] = obj\n  }\n\n  /**\n   * Gets an object defining the dynamic language elements of this Jexl\n   * instance.\n   * @returns {{ grammar: object, transforms: object }} A language definition\n   *    object\n   * @private\n   */\n  _getLang() {\n    return {\n      grammar: this._grammar,\n      transforms: this._transforms\n    }\n  }\n}\n\nmodule.exports = new Jexl()\nmodule.exports.Jexl = Jexl\n","/*\n * Jexl\n * Copyright 2019 Tom Shawver\n */\n\n/* eslint eqeqeq:0 */\n\n/**\n * A map of all expression elements to their properties. Note that changes\n * here may require changes in the Lexer or Parser.\n * @type {{}}\n */\nexports.elements = {\n  '.': { type: 'dot' },\n  '[': { type: 'openBracket' },\n  ']': { type: 'closeBracket' },\n  '|': { type: 'pipe' },\n  '{': { type: 'openCurl' },\n  '}': { type: 'closeCurl' },\n  ':': { type: 'colon' },\n  ',': { type: 'comma' },\n  '(': { type: 'openParen' },\n  ')': { type: 'closeParen' },\n  '?': { type: 'question' },\n  '+': {\n    type: 'binaryOp',\n    precedence: 30,\n    eval: (left, right) => left + right\n  },\n  '-': {\n    type: 'binaryOp',\n    precedence: 30,\n    eval: (left, right) => left - right\n  },\n  '*': {\n    type: 'binaryOp',\n    precedence: 40,\n    eval: (left, right) => left * right\n  },\n  '/': {\n    type: 'binaryOp',\n    precedence: 40,\n    eval: (left, right) => left / right\n  },\n  '//': {\n    type: 'binaryOp',\n    precedence: 40,\n    eval: (left, right) => Math.floor(left / right)\n  },\n  '%': {\n    type: 'binaryOp',\n    precedence: 50,\n    eval: (left, right) => left % right\n  },\n  '^': {\n    type: 'binaryOp',\n    precedence: 50,\n    eval: (left, right) => Math.pow(left, right)\n  },\n  '==': {\n    type: 'binaryOp',\n    precedence: 20,\n    eval: (left, right) => left == right\n  },\n  '!=': {\n    type: 'binaryOp',\n    precedence: 20,\n    eval: (left, right) => left != right\n  },\n  '>': {\n    type: 'binaryOp',\n    precedence: 20,\n    eval: (left, right) => left > right\n  },\n  '>=': {\n    type: 'binaryOp',\n    precedence: 20,\n    eval: (left, right) => left >= right\n  },\n  '<': {\n    type: 'binaryOp',\n    precedence: 20,\n    eval: (left, right) => left < right\n  },\n  '<=': {\n    type: 'binaryOp',\n    precedence: 20,\n    eval: (left, right) => left <= right\n  },\n  '&&': {\n    type: 'binaryOp',\n    precedence: 10,\n    eval: (left, right) => left && right\n  },\n  '||': {\n    type: 'binaryOp',\n    precedence: 10,\n    eval: (left, right) => left || right\n  },\n  in: {\n    type: 'binaryOp',\n    precedence: 20,\n    eval: (left, right) => {\n      if (typeof right === 'string') {\n        return right.indexOf(left) !== -1\n      }\n      if (Array.isArray(right)) {\n        return right.some(elem => elem === left)\n      }\n      return false\n    }\n  },\n  '!': {\n    type: 'unaryOp',\n    precedence: Infinity,\n    eval: right => !right\n  }\n}\n"],"names":["Evaluator","grammar","transforms","context","relativeContext","promise","Promise","this","_grammar","_transforms","_context","_relContext","ast","evalArray","value","all","eval","left","right","then","arr","operator","test","res","consequent","alternate","subject","relative","_filterRelative","expr","_filterStatic","from","Array","isArray","evalMap","const","transform","name","Error","args","apply","concat","resolve","handlers","type","call","map","elem","keys","Object","result","asts","key","vals","forEach","val","idx","promises","undefined","evalInst","push","values","results","Lexer","numericRegex","identRegex","escEscRegex","whitespaceRegex","preOpRegexElems","postOpRegexElems","minusNegatesAfter","getElements","str","regex","_getSplitRegex","split","filter","getTokens","elements","tokens","negate","i","length","_isWhitespace","raw","_isNegative","_createToken","tokenize","element","token","_unquote","match","parseFloat","_escapeRegExp","replace","elemArray","_splitRegex","sort","a","b","RegExp","join","some","quote","escQuoteRegex","substr","Parser","prefix","stopMap","_state","_tree","_exprStr","_relative","_stopMap","_cursor","_placeAtCursor","precedence","parent","_parent","node","_setParent","_nextIdentEncapsulate","_nextIdentRelative","_placeBeforeCursor","_subParser","isRelative","_curObjKey","states","expectOperand","tokenTypes","literal","toState","identifier","unaryOp","openParen","openCurl","handler","h","objStart","dot","openBracket","arrayStart","expectBinOp","binaryOp","pipe","question","ternaryStart","completable","expectTransform","expectObjKey","objKey","closeCurl","expectKeyValSep","colon","postTransform","postTransformArgs","traverse","subHandler","endStates","closeBracket","subExpression","closeParen","argVal","comma","objVal","arrayVal","ternaryMid","ternaryEnd","addToken","state","startExpr","_startSubExpression","stopState","_endSubExpression","_parentStop","typeOpts","handleFunc","addTokens","complete","defineProperty","writable","exprStr","let","PromiseSync","fn","_resolve","bind","_reject","catch","rejected","error","e","resolved","reject","Expression","lang","_lang","_lexer","_ast","compile","lexer","parser","_eval","evalSync","_getAst","Jexl","assign","defaultGrammar",".","[","]","|","{","}",":",",","(",")","?","+","-","*","/","//","Math","floor","%","^","pow","==","!=",">",">=","<","<=","&&","||","in","indexOf","!","Infinity","addBinaryOp","_addGrammarElement","addUnaryOp","weight","addTransform","addTransforms","hasOwnProperty","expression","createExpression","_getLang","getTransform","strs","reduce","acc","removeOp","obj"],"mappings":"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"}